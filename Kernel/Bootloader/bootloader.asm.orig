;(C) Patrick Cleavelin <patrick@uptrainsoftware.com>

[bits 16]

jmp start

times 3 - ($-$$) db 0
<<<<<<< HEAD
%include "src/BPB.inc"

start:
mov ax, 0x7c0
=======
%include "Kernel/Bootloader/BPB.inc"

start:
    mov ax, 0x7c0
>>>>>>> bootloader
	mov ds, ax
	mov es, ax ;set data segment and extra segment to cs (we can't move cs into
			   ;ds and ex directly)

	mov ah, 0x0 ;ah=0 (set video mode)
	mov al, 0x3 ;al=3 (80x25 mode)
	int 0x10 ;call the BIOS

	mov si, hello_msg
	call print_string

	mov ah, 0x41
	mov bx, 0x55aa
	mov dl, 0x80
	int 0x13
	jnc .supported

	mov si, bios_not_supported
	call print_string
<<<<<<< HEAD
	jmp .forever
=======
	jmp forever
>>>>>>> bootloader

	.supported:
		;Read first sector of root directory into RAM at 0x200
		mov al, [root_sector]
		mov [dap_sector_to_read_lo], al
		call read_disk

		;read the FAT into ram at 0x300
		mov al, [fat_sector]
		mov [dap_sector_to_read_lo], al
<<<<<<< HEAD
		mov ax, 0x400
=======
		mov ax, 0x300
>>>>>>> bootloader
		mov [dap_read_to_offset], ax
		call read_disk

	.read_dir:
<<<<<<< HEAD
		;Check for our kernel.bin
		mov bx, 0

		;Load filename into al
		mov si, [root_loc]
		.loop:
=======
		;Check for our KERNELB
		mov bx, 0

		;Load pointer to root directory in si
		;so that, we can check the file names
		mov si, [root_loc]
		.loop:
		    ; Get character of file name
>>>>>>> bootloader
			lodsb

			cmp al, [kernel_filename+bx]
			jne .not_same_character

			.same_character:
				inc bx
<<<<<<< HEAD
				cmp bx, 11
=======
				cmp bx, 7
>>>>>>> bootloader
				je .found_file
				jmp .loop

			.not_same_character:
				mov ax, [root_loc]
<<<<<<< HEAD
				add ax, 28
=======
				add ax, 8
>>>>>>> bootloader
				mov [root_loc], ax
				jmp .read_dir


		.found_file:
			mov si, found_file_msg
			call print_string

<<<<<<< HEAD
			;Load first cluster location into bx
			mov bx, [root_loc]
			mov ax, [bx+26]
			mov word [cluster], ax

			.loop_read:
				;mov dx, 2
				;mov ax, 2
				;div dx
				;cmp dx, 0
				;jnz .odd

				;0xFFF0
				;1+(3*n)/2

				.even:
					;Load first byte of FAT into ax
					xor eax, eax
					xor ebx, ebx
					mov bx, [cluster] ;WAY OF GETTING FAT LOCATION OFF LOOK AT DOCUMENT FOR MATH!
					add bx, [fat_loc]
					mov eax, [bx]

					add bx, 1
					mov edx, [bx]
					and edx, 0x0f
					shl edx, 8
					or eax, edx
					add eax, 33

					mov dword [dap_sector_to_read_lo], 0x101e
					mov ax, 0x200
					mov [dap_read_to_offset], ax
					call read_disk
					jmp [dap_read_to_offset]

				.odd:
			mov si, found_file_msg
			call print_string

	.forever:
		jmp .forever
=======
			;Begin loading each sector into memory
			mov bx, [root_loc]

			;The 8th byte is the sector location
			add bx, 7
			mov al, [bx]
			mov [cluster], al

			;Now find the same sector location in the FAT
			mov si, [fat_loc]
			mov bx, 0
			xor ax, ax
			.loop_sectors:
			    ;If we have gone through all FAT entries and still haven't found
			    ;the sector location, throw a fit of rage
			    cmp bx, 255
			    je fatal_error

                inc bx

			    ;Load an entry into ax
                lodsb

                ;Compare the sector in the root directory with the one in the FAT
                cmp ax, word [cluster]
                jnz .loop_sectors

            .read_sectors:
                ;Make bx the pointer into the FAT
                dec bx
                add bx, [fat_loc]

                mov ax, 0x400
                .loop_read:
                    add ax, 0x200
                    mov [dap_read_to_offset], ax

                    ;Save ax so we can load the sector location into it
                    push ax

                    ;Load sector location into ax
                    mov ax, [bx]

                    mov [dap_sector_to_read_lo], ax
                    call read_disk

                    ;Get next sector and check if it zero (for now that means the end of the file)
                    inc bx
                    mov ax, [bx]
                    jz .read_done

                    ;Get ax back
                    pop ax

                .read_done:
                    pop ax
                    jmp 0x7c0:0x600
                    jmp forever



fatal_error:
    mov si, fatal_error_msg
    call print_string

forever:
	jmp forever
>>>>>>> bootloader

read_disk:
	push ax
	push dx
	call reset_disk
	mov si, dap
	mov ah, 0x42
	mov dl, 0x80
	int 0x13
	pop dx
	pop ax
	ret

reset_disk:
	push ax
	mov ax, 0x0 ;Reset disk drive
	int 0x13
	pop ax
	ret


print_string:
	pusha ;preserve registers

	mov bp, sp ;setup stack
	.loop:
		lodsb ;load next byte from si
		or al, al ;do a check on al to set flags
		jz .end_loop ;if al is zero (null-terminator in string)
		mov ah, 0x0e ;ah=5 (teletype output)
		mov bx, 0 ;bx=0 (page number)
				  ;al (character) we get this from [si]
		int 0x10 ;print character to screen
		jmp .loop ;keep going
	.end_loop:
		mov sp, bp ;return stack to pre-call state
		popa
		ret


;The DAP (for reading sectors from floppy)
dap: db 0x10
dap_unused: db 0
dap_num_to_read: dw 1
dap_read_to_offset: dw 0x200
dap_read_to_segment: dw 0x7c0
dap_sector_to_read_lo: dd 0x00000000
dap_sector_to_read_hi: dd 0x00000000

<<<<<<< HEAD
fat_loc: dw 0x400 ;Location to load each sector of the FAT into
fat_sector: db 1
root_loc: dw 0x200
root_sector: db 19   ;The root directory starts at the 19th sector
=======
fat_loc: dw 0x300 ;Location to load each sector of the FAT into
fat_sector: db 1
root_loc: dw 0x200
root_sector: db 2   ;The root directory starts at the 3rd sector
>>>>>>> bootloader

cluster: dw 0

found_file_msg: db "Found Kernel...", 10, 13, 0
<<<<<<< HEAD
kernel_filename: db "KERNEL  BIN"
hello_msg: db "Bootloader v0.1", 10, 13, 0
bios_not_supported: db "LBA Extensions not supported", 10, 13, 0
=======
kernel_filename: db "KERNELB"
hello_msg: db "Bootloader v0.1", 10, 13, 0
bios_not_supported: db "LBA Extensions not supported", 10, 13, 0
fatal_error_msg: db "Fatal Error", 10, 13, 0
>>>>>>> bootloader
times 510 - ($-$$) db 0 ;nasm macro that fills the remaining sector space with
					   ;zeros
dw 0xaa55 ;boot signature BIOS looks for when searching for boot device